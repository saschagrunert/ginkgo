package types

import (
	"encoding/json"
	"strings"
	"time"
)

const GINKGO_FOCUS_EXIT_CODE = 197

// Report captures information about a Ginkgo test run
type Report struct {
	//SuitePath captures the absolute path to the test suite
	SuitePath string

	//SuiteDescription cpatures the description string passed to the DSL's RunSpecs() command
	SuiteDescription string

	//SuiteSucceeded captures the success or failure status of the test run
	//If true, the test run is considered successful.
	//If false, the test run is considered unsucccessful
	SuiteSucceeded bool

	//SuiteHasProgrammaticFocus captures whether the test suite has a test or set of tests that are programatically focused
	//(i.e an `FIt` or an `FDescribe`
	SuiteHasProgrammaticFocus bool

	//SpecialSuiteFailureReason may contain a special failure reason
	//For example, a test suite might be considered "failed" even if none of the individual specs
	//have a failure state.  For example, if the user has configured --fail-on-pending the test suite
	//will have failed if there are pending tests even though all non-pending tests may have passed.  In such
	//cases, Ginkgo populates SpecialSuiteFailureReason with a clear message indicating the reason for the failure.
	SpecialSuiteFailureReason string

	//PreRunStats contains a set of stats captured before the test run begins.  This is primarily used
	//by Ginkgo's reporter to tell the user how many specs are in the current suite (PreRunStats.TotalSpecs)
	//and how many it intends to run (PreRunStats.SpecsThatWillRun) after applying any relevant focus or skip filters.
	PreRunStats PreRunStats

	//StartTime and EndTime capture the start and end time of the test run
	StartTime time.Time
	EndTime   time.Time

	//RunTime captures the duration of the test run
	RunTime time.Duration

	//SuiteConfig captures the Ginkgo configuration governing this test run
	//SuiteConfig includes information necessary for reproducing an identical test run,
	//such as the random seed and any filters applied during the test run
	SuiteConfig SuiteConfig

	//SpecReports is a list of all SpecReports generated by this test run
	SpecReports SpecReports
}

//PreRunStats contains a set of stats captured before the test run begins.  This is primarily used
//by Ginkgo's reporter to tell the user how many specs are in the current suite (PreRunStats.TotalSpecs)
//and how many it intends to run (PreRunStats.SpecsThatWillRun) after applying any relevant focus or skip filters.
type PreRunStats struct {
	TotalSpecs       int
	SpecsThatWillRun int
}

//Add is ued by Ginkgo's parallel aggregation mechanisms to combine test run reports form individual parallel processes
//to form a complete final report.
func (report Report) Add(other Report) Report {
	report.SuiteSucceeded = report.SuiteSucceeded && other.SuiteSucceeded

	if other.StartTime.Before(report.StartTime) {
		report.StartTime = other.StartTime
	}

	if other.EndTime.After(report.EndTime) {
		report.EndTime = other.EndTime
	}

	if other.SpecialSuiteFailureReason != "" && report.SpecialSuiteFailureReason == "" {
		report.SpecialSuiteFailureReason = other.SpecialSuiteFailureReason
	}

	report.RunTime = report.EndTime.Sub(report.StartTime)

	reports := make(SpecReports, len(report.SpecReports)+len(other.SpecReports))
	for i := range report.SpecReports {
		reports[i] = report.SpecReports[i]
	}
	offset := len(report.SpecReports)
	for i := range other.SpecReports {
		reports[i+offset] = other.SpecReports[i]
	}

	report.SpecReports = reports
	return report
}

// SpecReport captures information about a Ginkgo spec.
type SpecReport struct {
	// ContainerHierarchyTexts is a slice containing the text strings of
	// all Describe/Context/When containers in this spec's hierarchy.
	ContainerHierarchyTexts []string

	// ContainerHierarchyLocations is a slice containing the CodeLocations of
	// all Describe/Context/When containers in this spec's hirerachy.
	ContainerHierarchyLocations []CodeLocation

	// LeafNodeType, LeadNodeLocation, and LeafNodeText capture the NodeType, CodeLocation, and text
	// of the Ginkgo node being tested (typically an NodeTypeIt node, though this can also be
	// one of the NodeTypesForSuiteLevelNodes node types)
	LeafNodeType     NodeType
	LeafNodeLocation CodeLocation
	LeafNodeText     string

	// State captures whether the spec has passed, failed, etc.
	State SpecState

	// StartTime and EndTime capture the start and end time of the spec
	StartTime time.Time
	EndTime   time.Time

	// RunTime captures the duration of the spec
	RunTime time.Duration

	// GinkgoParallelNode captures the parallel node that this spec ran on
	GinkgoParallelNode int

	//Failure is populated if a spec has failed, panicked, been interrupted, or skipped by the user (e.g. calling Skip())
	//It includes detailed information about the Failure
	Failure Failure

	// NumAttempts captures the number of times this Spec was run.  Flakey specs can be retried with
	// ginkgo --flake-attempts=N
	NumAttempts int

	// CapturedGinkgoWriterOutput contains text printed to the GinkgoWriter
	CapturedGinkgoWriterOutput string

	// CapturedStdOutErr contains text printed to stdout/stderr (when running in parallel)
	// This is always empty when running in series or calling CurrentSpecReport()
	// It is used internally by Ginkgo's reporter
	CapturedStdOutErr string
}

func (report SpecReport) MarshalJSON() ([]byte, error) {
	//All this to avoid emitting an empty Failure struct in the JSON
	out := struct {
		ContainerHierarchyTexts     []string
		ContainerHierarchyLocations []CodeLocation
		LeafNodeType                NodeType
		LeafNodeLocation            CodeLocation
		LeafNodeText                string
		State                       SpecState
		StartTime                   time.Time
		EndTime                     time.Time
		RunTime                     time.Duration
		GinkgoParallelNode          int
		Failure                     *Failure `json:",omitempty"`
		NumAttempts                 int
		CapturedGinkgoWriterOutput  string `json:",omitempty"`
		CapturedStdOutErr           string `json:",omitempty"`
	}{
		ContainerHierarchyTexts:     report.ContainerHierarchyTexts,
		ContainerHierarchyLocations: report.ContainerHierarchyLocations,
		LeafNodeType:                report.LeafNodeType,
		LeafNodeLocation:            report.LeafNodeLocation,
		LeafNodeText:                report.LeafNodeText,
		State:                       report.State,
		StartTime:                   report.StartTime,
		EndTime:                     report.EndTime,
		RunTime:                     report.RunTime,
		GinkgoParallelNode:          report.GinkgoParallelNode,
		Failure:                     nil,
		NumAttempts:                 report.NumAttempts,
		CapturedGinkgoWriterOutput:  report.CapturedGinkgoWriterOutput,
		CapturedStdOutErr:           report.CapturedStdOutErr,
	}

	if !report.Failure.IsZero() {
		out.Failure = &(report.Failure)
	}

	return json.Marshal(out)
}

// CombinedOutput returns a single string representation of both CapturedStdOutErr and CapturedGinkgoWriterOutput
// Note that both are empty when using CurrentSpecReport() so CurrentSpecReport().CombinedOutput() will always be empty.
// CombinedOutput() is used internally by Ginkgo's reporter.
func (report SpecReport) CombinedOutput() string {
	if report.CapturedStdOutErr == "" {
		return report.CapturedGinkgoWriterOutput
	}
	if report.CapturedGinkgoWriterOutput == "" {
		return report.CapturedStdOutErr
	}
	return report.CapturedStdOutErr + "\n" + report.CapturedGinkgoWriterOutput
}

//Failed returns true if report.State is one of the SpecStateFailureStates
// (SpecStateFAiled, SpecStatePanicked, SpecStateinterrupted)
func (report SpecReport) Failed() bool {
	return report.State.Is(SpecStateFailureStates...)
}

//FullText returns a concatenation of all the report.NodeTexts
func (report SpecReport) FullText() string {
	texts := []string{}
	texts = append(texts, report.ContainerHierarchyTexts...)
	if report.LeafNodeText != "" {
		texts = append(texts, report.LeafNodeText)
	}
	return strings.Join(texts, " ")
}

//FileName() returns the name of the file containing the spec
func (report SpecReport) FileName() string {
	return report.LeafNodeLocation.FileName
}

//LineNumber() returns the line number of the leaf node
func (report SpecReport) LineNumber() int {
	return report.LeafNodeLocation.LineNumber
}

//FailureMessage() returns the failure message (or empty string if the test hasn't failed)
func (report SpecReport) FailureMessage() string {
	return report.Failure.Message
}

//FailureLocation() returns the location of the failure (or an empty CodeLocation if the test hasn't failed)
func (report SpecReport) FailureLocation() CodeLocation {
	return report.Failure.Location
}

type SpecReports []SpecReport

//WithLeafNodeType returns the subset of SpecReports with LeafNodeType matching one of the requested NodeTypes
func (reports SpecReports) WithLeafNodeType(nodeType ...NodeType) SpecReports {
	out := SpecReports{}
	for _, report := range reports {
		if report.LeafNodeType.Is(nodeType...) {
			out = append(out, report)
		}
	}
	return out
}

//WithState returns the subset of SpecReports with State matching one of the requested SpecStates
func (reports SpecReports) WithState(states ...SpecState) SpecReports {
	out := SpecReports{}
	for _, report := range reports {
		if report.State.Is(states...) {
			out = append(out, report)
		}
	}
	return out
}

//CountWithState returns the number of SpecReports with State matching one of the requested SpecStates
func (reports SpecReports) CountWithState(states ...SpecState) int {
	n := 0
	for _, report := range reports {
		if report.State.Is(states...) {
			n += 1
		}
	}
	return n
}

//CountWithState returns the number of SpecReports that passed after multiple attempts
func (reports SpecReports) CountOfFlakedSpecs() int {
	n := 0
	for _, report := range reports.WithState(SpecStatePassed) {
		if report.NumAttempts > 1 {
			n += 1
		}
	}
	return n
}

// Failure captures failure information for an individual test
type Failure struct {
	// Message - the failure message passed into Fail(...).  When using a matcher library
	// like Gomega, this will contain the failure message generated by Gomega.
	Message string

	// Location - the CodeLocation where the failure occurred
	// This CodeLocation will include a fully-populated StackTrace
	Location CodeLocation

	// ForwardedPanic - if the failure represents a captured panic (i.e. Summary.State == SpecStatePanicked)
	// then ForwardedPanic will be populated with a string representation of the captured panic.
	ForwardedPanic string `json:",omitempty"`

	// FailureNodeContext - one of three contexts describing the node in which the failure occured:
	// FailureNodeIsLeafNode means the failure occured in the leaf node of the associated SpecReport. None of the other FailureNode fields will be populated
	// FailureNodeAtTopLevel means the failure occured in a non-leaf node that is defined at the top-level of the spec (i.e. not in a container). FailureNodeType and FailureNodeLocation will be populated.
	// FailureNodeInContainer means the failure occured in a non-leaf node that is defined within a container.  FailureNodeType, FailureNodeLocaiton, and FailureNodeContainerIndex will be populated.
	//
	//  FailureNodeType will contain the NodeType of the node in which the failure occurred.
	//  FailureNodeLocation will contain the CodeLocation of the node in which the failure occurred.
	// If populated, FailureNodeContainerIndex will be the index into SpecReport.ContainerHierarchyTexts and SpecReport.ContainerHierarchyLocations that represents the parent container of the node in which the failure occurred.
	FailureNodeContext        FailureNodeContext
	FailureNodeType           NodeType
	FailureNodeLocation       CodeLocation
	FailureNodeContainerIndex int
}

func (f Failure) IsZero() bool {
	return f == Failure{}
}

// FailureNodeContext captures the location context for the node containing the failing line of code
type FailureNodeContext uint

const (
	FailureNodeContextInvalid FailureNodeContext = iota

	FailureNodeIsLeafNode
	FailureNodeAtTopLevel
	FailureNodeInContainer
)

func (fnc *FailureNodeContext) UnmarshalJSON(b []byte) error {
	var dec string
	if err := json.Unmarshal(b, &dec); err != nil {
		return err
	}
	switch strings.ToLower(dec) {
	default:
		*fnc = FailureNodeContextInvalid
	case "failurenodeisleafnode":
		*fnc = FailureNodeIsLeafNode
	case "failurenodeattoplevel":
		*fnc = FailureNodeAtTopLevel
	case "failurenodeincontainer":
		*fnc = FailureNodeInContainer
	}
	return nil
}

func (fnc FailureNodeContext) MarshalJSON() ([]byte, error) {
	switch fnc {
	case FailureNodeIsLeafNode:
		return json.Marshal("FailureNodeIsLeafNode")
	case FailureNodeAtTopLevel:
		return json.Marshal("FailureNodeAtTopLevel")
	case FailureNodeInContainer:
		return json.Marshal("FailureNodeInContainer")
	}
	return json.Marshal(nil)
}

// SpecState captures the state of a spec
// To determine if a given `state` represents a failure state, use `state.Is(SpecStateFailureStates...)`
type SpecState uint

const (
	SpecStateInvalid SpecState = iota

	SpecStatePending
	SpecStateSkipped
	SpecStatePassed
	SpecStateFailed
	SpecStatePanicked
	SpecStateInterrupted
)

func (s SpecState) String() string {
	switch s {
	case SpecStatePending:
		return "pending"
	case SpecStateSkipped:
		return "skipped"
	case SpecStatePassed:
		return "passed"
	case SpecStateFailed:
		return "failed"
	case SpecStatePanicked:
		return "panicked"
	case SpecStateInterrupted:
		return "interrupted"
	}

	return "INVALID SPEC STATE"
}

func (s *SpecState) UnmarshalJSON(b []byte) error {
	var dec string
	if err := json.Unmarshal(b, &dec); err != nil {
		return err
	}
	switch strings.ToLower(dec) {
	default:
		*s = SpecStateInvalid
	case "pending":
		*s = SpecStatePending
	case "skipped":
		*s = SpecStateSkipped
	case "passed":
		*s = SpecStatePassed
	case "failed":
		*s = SpecStateFailed
	case "panicked":
		*s = SpecStatePanicked
	case "interrupted":
		*s = SpecStateInterrupted
	}
	return nil
}

func (s SpecState) MarshalJSON() ([]byte, error) {
	if s == SpecStateInvalid {
		return json.Marshal(nil)
	}
	return json.Marshal(s.String())
}

var SpecStateFailureStates = []SpecState{SpecStateFailed, SpecStatePanicked, SpecStateInterrupted}

func (state SpecState) Is(states ...SpecState) bool {
	for _, testState := range states {
		if testState == state {
			return true
		}
	}

	return false
}

// NodeType captures the type of a given Ginkgo Node
type NodeType uint

const (
	NodeTypeInvalid NodeType = iota

	NodeTypeContainer
	NodeTypeIt

	NodeTypeBeforeEach
	NodeTypeJustBeforeEach
	NodeTypeAfterEach
	NodeTypeJustAfterEach

	NodeTypeBeforeSuite
	NodeTypeSynchronizedBeforeSuite
	NodeTypeAfterSuite
	NodeTypeSynchronizedAfterSuite

	NodeTypeReportAfterEach
	NodeTypeReportAfterSuite
)

var NodeTypesForContainerAndIt = []NodeType{NodeTypeContainer, NodeTypeIt}
var NodeTypesForSuiteLevelNodes = []NodeType{NodeTypeBeforeSuite, NodeTypeSynchronizedBeforeSuite, NodeTypeAfterSuite, NodeTypeSynchronizedAfterSuite, NodeTypeReportAfterSuite}

func (nt NodeType) Is(nodeTypes ...NodeType) bool {
	for _, nodeType := range nodeTypes {
		if nt == nodeType {
			return true
		}
	}

	return false
}

func (nt NodeType) String() string {
	switch nt {
	case NodeTypeContainer:
		return "Container"
	case NodeTypeIt:
		return "It"
	case NodeTypeBeforeEach:
		return "BeforeEach"
	case NodeTypeJustBeforeEach:
		return "JustBeforeEach"
	case NodeTypeAfterEach:
		return "AfterEach"
	case NodeTypeJustAfterEach:
		return "JustAfterEach"
	case NodeTypeBeforeSuite:
		return "BeforeSuite"
	case NodeTypeSynchronizedBeforeSuite:
		return "SynchronizedBeforeSuite"
	case NodeTypeAfterSuite:
		return "AfterSuite"
	case NodeTypeSynchronizedAfterSuite:
		return "SynchronizedAfterSuite"
	case NodeTypeReportAfterEach:
		return "ReportAfterEach"
	case NodeTypeReportAfterSuite:
		return "ReportAfterSuite"
	}
	return "INVALID NODE TYPE"
}

func (nt *NodeType) UnmarshalJSON(b []byte) error {
	var dec string
	if err := json.Unmarshal(b, &dec); err != nil {
		return err
	}
	switch strings.ToLower(dec) {
	default:
		*nt = NodeTypeInvalid
	case "container":
		*nt = NodeTypeContainer
	case "it":
		*nt = NodeTypeIt
	case "beforeeach":
		*nt = NodeTypeBeforeEach
	case "justbeforeeach":
		*nt = NodeTypeJustBeforeEach
	case "aftereach":
		*nt = NodeTypeAfterEach
	case "justaftereach":
		*nt = NodeTypeJustAfterEach
	case "beforesuite":
		*nt = NodeTypeBeforeSuite
	case "synchronizedbeforesuite":
		*nt = NodeTypeSynchronizedBeforeSuite
	case "aftersuite":
		*nt = NodeTypeAfterSuite
	case "synchronizedaftersuite":
		*nt = NodeTypeSynchronizedAfterSuite
	case "reportaftereach":
		*nt = NodeTypeReportAfterEach
	case "reportaftersuite":
		*nt = NodeTypeReportAfterSuite
	}
	return nil
}

func (nt NodeType) MarshalJSON() ([]byte, error) {
	if nt == NodeTypeInvalid {
		return json.Marshal(nil)
	}
	return json.Marshal(nt.String())
}
